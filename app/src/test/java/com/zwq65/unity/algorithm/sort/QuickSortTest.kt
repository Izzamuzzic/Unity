package com.zwq65.unity.algorithm.sort

import org.junit.Test

/**
 *================================================
 * 快速排序
 *
 * 快速排序由C. A. R. Hoare在1962年提出。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，
 * 然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。
 * 1.从第一个元素开始，该元素可以认为已经被排序
 * 2.取出下一个元素，在已经排序的元素序列中从后向前扫描
 * 3.如果该元素（已排序）大于新元素，将该元素移到下一位置
 * 4.重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置
 * 5.将新元素插入到该位置后
 * 6.重复步骤 2~5
 *
 * 快速排序总结：
 * 对于快速排序的时间度取决于其递归的深度，如果递归深度又决定于每次关键值得取值所以在最好的情况下每次都取到数组中间值，那么此时算法时间复杂度最优为 O(nlogn)。当然最坏情况就是之前我们分析的有序数组，那么每次都需要进行 n 次比较则 时间复杂度为 O(n²)，但是在平均情况 时间复杂度为 O(nlogn)
 * 空间复杂度为 O(1)。
 * 快速排序为不稳定排序。
 *
 * Created by NIRVANA on 2018/3/2
 * Contact with <zwq651406441@gmail.com>
 *================================================
 */
class QuickSortTest {
    companion object {
        val array = arrayOf(11, 23, 3, 6564, 342, 545, 7, 5)
    }

    @Test
    fun sort() {
        //外层循环控制需要排序的趟数(从1开始因为将第0位看成了有序数据)
        quickSort(array, 0, 7)

        for (item in array) {
            println(item)
        }
    }

    /**
     * 快速排序
     *
     * @param arr
     * @param L   指向数组第一个元素
     * @param R   指向数组最后一个元素
     */
    private fun quickSort(arr: Array<Int>, L: Int, R: Int) {
        var i = L
        var j = R
        //支点
        val pivot = arr[(L + R) / 2]
        //左右两端进行扫描，只要两端还没有交替，就一直扫描
        while (i <= j) {
            //寻找直到比支点大的数
            while (pivot > arr[i])
                i++
            //寻找直到比支点小的数
            while (pivot < arr[j])
                j--
            //此时已经分别找到了比支点小的数(右边)、比支点大的数(左边)，它们进行交换
            if (i <= j) {
                val temp = arr[i]
                arr[i] = arr[j]
                arr[j] = temp
                i++
                j--
            }
        }
        //上面一个while保证了第一趟排序支点的左边比支点小，支点的右边比支点大了。

        //“左边”再做排序，直到左边剩下一个数(递归出口)
        if (L < j)
            quickSort(arr, L, j)
        //“右边”再做排序，直到右边剩下一个数(递归出口)
        if (i < R)
            quickSort(arr, i, R)
    }
}